rmarkdown::render("vignettes/ktweedie-vignette.Rmd", output_format = rmarkdown::latex_document())
rmarkdown::render("vignettes/ktweedie-vignette.Rmd", output_format = rmarkdown::latex_document())
rmarkdown::render("vignettes/ktweedie-vignette.Rmd", output_format = rmarkdown::latex_document())
rmarkdown::render("vignettes/ktweedie-vignette.Rmd", output_format = rmarkdown::latex_document())
library(ktweedie)
library(ktweedie)
library(ktweedie)
x <- dat$x
dim(x)
library(ktweedie)
library(ktweedie)
library(ktweedie)
load("~/Documents/Research/Tweedie/Package/ktweedie/data/dat.rda")
dim(dat$x)
library(ktweedie)
dat$x
dim(dat$x)
## code to prepare `dat` dat goes here
library(tweedie)
rand_tweedie<- function(mu,...) {
Y <- rtweedie(1, mu = mu,...)
Y
}
phi <- 0.5
rho <- 1.5
P <- 10
N <- 200
beta.true <- c(6, -4, 3, 2, -2, rep(0, P-5))
x <- matrix(rnorm(N * P), N, P)
Fx <- sin(x) %*% beta.true
mu <- exp(Fx)
y = sapply(mu, rand_tweedie, xi = rho, phi = phi)
dat <- list(x, y)
names(dat) <- c("x", "y")
usethis::use_data(dat, overwrite = TRUE)
library(ktweedie)
dim(dat$x)
## code to prepare `dat` dat goes here
library(tweedie)
set.seed(20220715)
rand_tweedie<- function(mu,...) {
Y <- rtweedie(1, mu = mu,...)
Y
}
phi <- 0.5
rho <- 1.5
P <- 10
N <- 200
beta.true <- c(6, -4, 3, 2, -2, rep(0, P-5))
x <- matrix(rnorm(N * P), N, P)
Fx <- sin(x) %*% beta.true
mu <- exp(Fx)
y = sapply(mu, rand_tweedie, xi = rho, phi = phi)
dat <- list(x, y)
names(dat) <- c("x", "y")
usethis::use_data(dat, overwrite = TRUE)
library(ktweedie)
lam1.seq <- c(1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1)
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-8),
lam1 = lam1.seq)
str(fit)
library(ktweedie)
library(ktweedie)
dat
hist(dat$y)
hist(dat$y, breaks = 1000)
summary(dat$y)
head(y)
## code to prepare `dat` dat goes here
library(tweedie)
set.seed(20220715)
rand_tweedie<- function(mu,...) {
Y <- rtweedie(1, mu = mu,...)
Y
}
phi <- 0.5
rho <- 1.5
P <- 50
N <- 200
beta.true <- c(6, -4, 3, 2, -2, rep(0, P-5))
x <- matrix(rnorm(N * P), N, P)
Fx <- sin(x) %*% beta.true
mu <- exp(Fx)
y = sapply(mu, rand_tweedie, xi = rho, phi = phi)
dat <- list(x, y)
names(dat) <- c("x", "y")
usethis::use_data(dat, overwrite = TRUE)
library(ktweedie)
head(y)
25*0.9^9
25*0.9*14
25*0.9^14
library(ktweedie)
library(ktweedie)
install.packages("qpdf")
library(ktweedie)
devtools::check_win_release()
( cv1d <- ktd_cv(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-8),
lambda = 10^(-8:-1),
nfolds = 5) )
isClass(rbfdot())
is(rbfdot(), "rbfdot")
rbfdot()
class(rbfdot())
str(rbfdot())
is(rbfdot(), "rbfkernel")
library(ktweedie)
devtools::check_win_release()
devtools::check_win_release()
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-6),
lam1 = 10^(-5:1))
newx <- matrix(rnorm(10 * ncol(dat$x)), nrow = 10)
pred <- ktd_predict(model = fit, newdata = newx, which.lam1 = 3, type = "link")
str(pred)
library(ktweedie)
library(ktweedie)
( cv1d <- ktd_cv(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-8),
lambda = 10^(-8:-1),
nfolds = 5) )
library(ktweedie)
lam1.seq <- c(1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1)
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-8),
lam1 = lam1.seq)
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
cv2d
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
innerpartol = 1e-4,
verbose = TRUE)
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
library(ktweedie)
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
# Set sparsity to TRUE and a lam2 to control the level of sparsity
# Decrease lam2 if "WARNING: All weights are zero..."
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
library(ktweedie)
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
# Set sparsity to TRUE and a lam2 to control the level of sparsity
# Decrease lam2 if "WARNING: All weights are zero..."
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
# Set sparsity to TRUE and a lam2 to control the level of sparsity
# Decrease lam2 if "WARNING: All weights are zero..."
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
fit.sparse$estimates$`l1 0.00120057 l2 6 rbfkernel 0.000328465`$weight
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
# Set sparsity to TRUE and a lam2 to control the level of sparsity
# Decrease lam2 if "WARNING: All weights are zero..."
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
# Set sparsity to TRUE and a lam2 to control the level of sparsity
# Decrease lam2 if "WARNING: All weights are zero..."
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
# Set sparsity to TRUE and a lam2 to control the level of sparsity
# Decrease lam2 if "WARNING: All weights are zero..."
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 60,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 600,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
library(ktweedie)
devtools::check_win_release()
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
# Set sparsity to TRUE and a lam2 to control the level of sparsity
# Decrease lam2 if "WARNING: All weights are zero..."
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-5, 1e1),
sigma = c(1e-5, 1e1),
ncoefs = 10)
# Set sparsity to TRUE and a lam2 to control the level of sparsity
# Decrease lam2 if "WARNING: All weights are zero..."
fit.sparse <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda,
sparsity = TRUE,
lam2 = 6,
partol = 1e-4,
innerpartol = 1e-4,
verbose = TRUE)
library(ktweedie)
devtools::check_win_release()
library(ktweedie)
library(ktweedie)
library(ktweedie)
( cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-10, 1e0),
sigma = c(1e-10, 1e0),
ncoefs = 6) )
install.packages("gglasso")
library(ktweedie)
library(ktweedie)
fit.ktd <- ktd_estimate(x = x, y = y,
kern = rbfdot(sigma = 0.1),
lam1 = c(0.01, 0.1, 1))
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
set.seed(20220718)
library(ktweedie)
data(dat)
x <- dat$x
y <- dat$y
fit.ktd <- ktd_estimate(x = x, y = y,
kern = rbfdot(sigma = 0.1),
lam1 = c(0.01, 0.1, 1))
str(fit.ktd$estimates)
fit.sktd <- ktd_estimate(x = x, y = y,
kern = rbfdot(sigma = 0.1),
lam1 = 1,
sparsity = TRUE,
lam2 = 1)
head(fit.sktd$estimates[[1]]$weight)
library(ktweedie)
library(ktweedie)
devtools::check_win_release()
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
qpdf
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
qpdf
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.which(Sys.getenv(qpdf"))
_
)
""
Sys.which(Sys.getenv("qpdf"))
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
devtools::build_vignettes()
devtools::build_vignettes()
library(ktweedie)
vignette <- readRDS("~/Documents/Research/Tweedie/Package/ktweedie/Meta/vignette.rds")
vignette
devtools::build_vignettes()
( cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-10, 1e0),
sigma = c(1e-10, 1e0),
ncoefs = 6) )
### Cross-validation
# Provide the kernel function name (e.g. rbfdot) to the argument kernfunc,
# NOT the kernel function object, e.g. rbfdot(sigma = 1).
# Provide ranges where the candidate lambdas and sigmas are drawn from
# to the arguments lambda and sigma.
# The number of pairs of candidates to select from is specified by ncoefs.
( cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-10, 1e0),
sigma = c(1e-10, 1e0),
ncoefs = 6) )
### Followed by fitting
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda)
pkgname <- "ktweedie"
source(file.path(R.home("share"), "R", "examples-header.R"))
options(warn = 1)
base::assign(".ExTimings", "ktweedie-Ex.timings", pos = 'CheckExEnv')
base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
base::assign(".format_ptime",
function(x) {
if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
options(OutDec = '.')
format(x[1L:3L], digits = 7L)
},
pos = 'CheckExEnv')
### * </HEADER>
library('ktweedie')
base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
cleanEx()
nameEx("as.kernelMatrix")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
## Create toy data
x <- rbind(matrix(rnorm(10),,2),matrix(rnorm(10,mean=3),,2))
y <- matrix(c(rep(1,5),rep(-1,5)))
K <- as.kernelMatrix(crossprod(t(x)))
K
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("as.kernelMatrix", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("dots")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
rbfkernel <- rbfdot(sigma = 0.1)
rbfkernel
kpar(rbfkernel)
## create two vectors
x <- rnorm(10)
y <- rnorm(10)
## calculate dot product
rbfkernel(x,y)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("dots", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("kernel-class")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
rbfkernel <- rbfdot(sigma = 0.1)
rbfkernel
is(rbfkernel)
kpar(rbfkernel)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("kernel-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("kernelMatrix")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
## use the spam data
x <- matrix(rnorm(10*10),10,10)
## initialize kernel function
rbf <- rbfdot(sigma = 0.05)
rbf
## calculate kernel matrix
kernelMatrix(rbf, x)
y <- matrix(rnorm(10*1),10,1)
## calculate the quadratic kernel expression
kernelPol(rbf, x, ,y)
## calculate the kernel expansion
kernelMult(rbf, x, ,y)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("kernelMatrix", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("ktd_cv")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
# Provide a sequence of candidate values to the argument lambda.
# ktd_cv() will perform cross-validation to determine which is the best.
( cv1d <- ktd_cv(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-8),
lambda = 10^(-8:-1),
nfolds = 5) )
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("ktd_cv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("ktd_cv2d")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
### Cross-validation
# Provide the kernel function name (e.g. rbfdot) to the argument kernfunc,
# NOT the kernel function object, e.g. rbfdot(sigma = 1).
# Provide ranges where the candidate lambdas and sigmas are drawn from
# to the arguments lambda and sigma.
# The number of pairs of candidates to select from is specified by ncoefs.
( cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-10, 1e0),
sigma = c(1e-10, 1e0),
ncoefs = 6) )
### Followed by fitting
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("ktd_cv2d", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("ktd_estimate")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
###### ktweedie ######
# Provide a sequence of candidate values to the argument lam1.
# Provide a kernel object to the argument kern.
lam1.seq <- c(1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1)
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-8),
lam1 = lam1.seq)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("ktd_estimate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("ktd_predict")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
# Fit a ktweedie model
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-6),
lam1 = 10^(-5:1))
# Generate newx at which predictions are to be made.
# The newdata should have the same dimension as the original trainig data.
newx <- matrix(rnorm(10 * ncol(dat$x)), nrow = 10)
pred <- ktd_predict(model = fit, newdata = newx,
which.lam1 = 3, type = "link")
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("ktd_predict", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
### * <FOOTER>
###
cleanEx()
options(digits = 7L)
base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
grDevices::dev.off()
###
### Local variables: ***
### mode: outline-minor ***
### outline-regexp: "\\(> \\)?### [*]+" ***
### End: ***
quit('no')
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.which(Sys.getenv())
Sys.which(Sys.getenv())
str(Sys.which(Sys.getenv()))
attr(Sys.which(Sys.getenv()), "names")
