### * </HEADER>
library('ktweedie')
base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
cleanEx()
nameEx("as.kernelMatrix")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
## Create toy data
x <- rbind(matrix(rnorm(10),,2),matrix(rnorm(10,mean=3),,2))
y <- matrix(c(rep(1,5),rep(-1,5)))
K <- as.kernelMatrix(crossprod(t(x)))
K
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("as.kernelMatrix", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("dots")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
rbfkernel <- rbfdot(sigma = 0.1)
rbfkernel
kpar(rbfkernel)
## create two vectors
x <- rnorm(10)
y <- rnorm(10)
## calculate dot product
rbfkernel(x,y)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("dots", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("kernel-class")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
rbfkernel <- rbfdot(sigma = 0.1)
rbfkernel
is(rbfkernel)
kpar(rbfkernel)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("kernel-class", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("kernelMatrix")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
## use the spam data
x <- matrix(rnorm(10*10),10,10)
## initialize kernel function
rbf <- rbfdot(sigma = 0.05)
rbf
## calculate kernel matrix
kernelMatrix(rbf, x)
y <- matrix(rnorm(10*1),10,1)
## calculate the quadratic kernel expression
kernelPol(rbf, x, ,y)
## calculate the kernel expansion
kernelMult(rbf, x, ,y)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("kernelMatrix", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("ktd_cv")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
# Provide a sequence of candidate values to the argument lambda.
# ktd_cv() will perform cross-validation to determine which is the best.
( cv1d <- ktd_cv(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-8),
lambda = 10^(-8:-1),
nfolds = 5) )
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("ktd_cv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("ktd_cv2d")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
### Cross-validation
# Provide the kernel function name (e.g. rbfdot) to the argument kernfunc,
# NOT the kernel function object, e.g. rbfdot(sigma = 1).
# Provide ranges where the candidate lambdas and sigmas are drawn from
# to the arguments lambda and sigma.
# The number of pairs of candidates to select from is specified by ncoefs.
( cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-10, 1e0),
sigma = c(1e-10, 1e0),
ncoefs = 6) )
### Followed by fitting
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = cv2d$Best_sigma),
lam1 = cv2d$Best_lambda)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("ktd_cv2d", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("ktd_estimate")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
###### ktweedie ######
# Provide a sequence of candidate values to the argument lam1.
# Provide a kernel object to the argument kern.
lam1.seq <- c(1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e0, 1e1)
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-8),
lam1 = lam1.seq)
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("ktd_estimate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
cleanEx()
nameEx("ktd_predict")
flush(stderr()); flush(stdout())
base::assign(".ptime", proc.time(), pos = "CheckExEnv")
# Fit a ktweedie model
fit <- ktd_estimate(x = dat$x, y = dat$y,
kern = rbfdot(sigma = 1e-6),
lam1 = 10^(-5:1))
# Generate newx at which predictions are to be made.
# The newdata should have the same dimension as the original trainig data.
newx <- matrix(rnorm(10 * ncol(dat$x)), nrow = 10)
pred <- ktd_predict(model = fit, newdata = newx,
which.lam1 = 3, type = "link")
base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
base::cat("ktd_predict", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
### * <FOOTER>
###
cleanEx()
options(digits = 7L)
base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
grDevices::dev.off()
###
### Local variables: ***
### mode: outline-minor ***
### outline-regexp: "\\(> \\)?### [*]+" ***
### End: ***
quit('no')
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.which(Sys.getenv())
Sys.which(Sys.getenv())
str(Sys.which(Sys.getenv()))
attr(Sys.which(Sys.getenv()), "names")
Sys.which(Sys.getenv())
Sys.getenv()
Sys.getenv(qpdf)
Sys.getenv("qpdf")
Sys.setenv("qpdf", "/opt/homebrew/bin")
Sys.setenv("qpdf" = "/opt/homebrew/bin")
Sys.getenv()
devtools::check_mac_release()
devtools::check_mac_release()
library(ktweedie)
devtools::check_mac_release()
devtools::check_mac_release()
# lasso
lasso <- function(x, l, w) {
y <- l * w * abs(x)
return(y)
}
pdf(file = "/Users/YLIAN/Documents/Research/REE/JSS/Lasso_value.pdf", width = 6, height = 5)
x <- seq(-6.5, 6.5, by = 0.01)
y <- numeric(length(x))
for (i in seq(length(x))) {
y[i] <- lasso(x[i], 1, 1)
}
plot(y~x, type = 'l', lty = 1,
ylab = expression(paste(Omega["Lasso"],"(", xi, ")" )),
xlab = expression(paste(xi)),
lwd = 2,
main = "Weighted Lasso Penalty")
for (i in seq(length(x))) {
y[i] <- lasso(x[i], 1, 2)
}
lines(y~x, col = 2, lty = 2, lwd = 2)
for (i in seq(length(x))) {
y[i] <- lasso(x[i], 1, 0.5)
}
lines(y~x, col = 3, lty = 3, lwd = 2)
for (i in seq(length(x))) {
y[i] <- lasso(x[i], 1, 0)
}
lines(y~x, col = 4, lty = 4, lwd = 2)
legend("bottomright",
title = expression(paste(lambda, " = 1")),
legend = c("w = 0.0", "w = 0.5", "w = 1.0", "w = 2.0"),
lty = c(4, 3, 1, 2), col = c(4, 3, 1, 2), lwd = 2, bg = "white")
dev.off()
lasso_thresh <- function(x, l, w) {
if (abs(x) > l * w) {
y <- x - x/abs(x)*l*w
} else {
y <- 0
}
}
pdf(file = "/Users/YLIAN/Documents/Research/REE/JSS/Lasso_thresh.pdf", width = 6, height = 5)
x <- seq(-6.5, 6.5, by = 0.01)
y <- numeric(length(x))
for (i in seq(length(x))) {
y[i] <- lasso_thresh(x[i], 1, 1)
}
plot(y~x, type = 'l', lty = 1,
ylab = expression(paste(S["Lasso"],"(", xi, ")" )),
xlab = expression(paste(xi)),
lwd = 2,
main = "Weighted Lasso Thresholding")
for (i in seq(length(x))) {
y[i] <- lasso_thresh(x[i], 1, 2)
}
lines(y~x, col = 2, lty = 2, lwd = 2)
for (i in seq(length(x))) {
y[i] <- lasso_thresh(x[i], 1, 0.5)
}
lines(y~x, col = 3, lty = 3, lwd = 2)
for (i in seq(length(x))) {
y[i] <- lasso_thresh(x[i], 1, 0)
}
lines(y~x, col = 4, lty = 4, lwd = 2)
legend("bottomright",
title = expression(paste(lambda, " = 1")),
legend = c("w = 0.0", "w = 0.5", "w = 1.0", "w = 2.0"),
lty = c(4, 3, 1, 2), col = c(4, 3, 1, 2), lwd = 2, bg = "white")
dev.off()
# scad
source("~/Documents/Research/REE/JSS/Lasso_value.R")
scad <- function(x, l1, l2, w) {
if (abs(x) <= l1/w) {
y <- l1 * w * abs(x)
} else if (l1/w < abs(x) & abs(x) < l1 * l2/w) {
y <- (2*l1*l2*w*abs(x)-w^2*x^2-l1^2)/(2*(l2-1))
} else {
y <- l1^2*(l2+1)/2
}
return(y)
}
pdf(file = "/Users/YLIAN/Documents/Research/REE/JSS/SCAD_value.pdf", width = 6, height = 5)
x <- seq(-6.5, 6.5, by = 0.01)
y <- numeric(length(x))
for (i in seq(length(x))) {
y[i] <- scad(x[i], 1, 3, 1)
}
plot(y~x, type = 'l', lty = 1,
ylab = expression(paste(Omega["SCAD"],"(", xi, ")" )),
xlab = expression(paste(xi)),
lwd = 2,
main = "Weighted SCAD Penalty")
for (i in seq(length(x))) {
y[i] <- scad(x[i], 1, 3, 2)
}
lines(y~x, col = 2, lty = 2, lwd = 2)
for (i in seq(length(x))) {
y[i] <- scad(x[i], 1, 3, 0.5)
}
lines(y~x, col = 3, lty = 3, lwd = 2)
for (i in seq(length(x))) {
y[i] <- scad(x[i], 1, 3, 0)
}
lines(y~x, col = 4, lty = 4, lwd = 2)
legend("bottomright",
title = expression(paste(lambda[1], " = 1, ", lambda[2], " = 3")),
legend = c("w = 0.0", "w = 0.5", "w = 1.0", "w = 2.0"),
lty = c(4, 3, 1, 2), col = c(4, 3, 1, 2), lwd = 2, bg = "white")
dev.off()
scad_thresh <- function(x, l1, l2, w) {
if (abs(x) <= 2*l1*w) {
y <- lasso_thresh(x, l1, w)
} else if (2*l1*w < abs(x) & abs(x) < l1 * l2 * w) {
y <- (l2-1)/(l2-2) * (lasso_thresh(x = x, l = l1 * l2/(l2-1), w = w))
} else {
y <- x
}
return(y)
}
pdf(file = "/Users/YLIAN/Documents/Research/REE/JSS/SCAD_thresh.pdf", width = 6, height = 5)
x <- seq(-6.5, 6.5, by = 0.01)
y <- numeric(length(x))
for (i in seq(length(x))) {
y[i] <- scad_thresh(x[i], 1, 3, 1)
}
plot(y~x, type = 'l', lty = 1,
ylab = expression(paste(S["SCAD"],"(", xi, ")" )),
xlab = expression(paste(xi)),
lwd = 2,
main = "Weighted SCAD Thresholding")
for (i in seq(length(x))) {
y[i] <- scad_thresh(x[i], 1, 3, 2)
}
lines(y~x, col = 2, lty = 2, lwd = 2)
for (i in seq(length(x))) {
y[i] <- scad_thresh(x[i], 1, 3, 0.5)
}
lines(y~x, col = 3, lty = 3, lwd = 2)
for (i in seq(length(x))) {
y[i] <- scad_thresh(x[i], 1, 3, 0)
}
lines(y~x, col = 4, lty = 4, lwd = 2)
legend("bottomright",
title = expression(paste(lambda[1], " = 1, ", lambda[2], " = 3")),
legend = c("w = 0.0", "w = 0.5", "w = 1.0", "w = 2.0"),
lty = c(4, 3, 1, 2), col = c(4, 3, 1, 2), lwd = 2, bg = "white")
dev.off()
# scad
source("~/Documents/Research/REE/JSS/Lasso_value.R")
scad <- function(x, l1, l2, w) {
if (abs(x) <= l1/w) {
y <- l1 * w * abs(x)
} else if (l1/w < abs(x) & abs(x) < l1 * l2/w) {
y <- (2*l1*l2*w*abs(x)-w^2*x^2-l1^2)/(2*(l2-1))
} else {
y <- l1^2*(l2+1)/2
}
return(y)
}
pdf(file = "/Users/YLIAN/Documents/Research/REE/JSS/SCAD_value.pdf", width = 6, height = 5)
x <- seq(-6.5, 6.5, by = 0.01)
y <- numeric(length(x))
for (i in seq(length(x))) {
y[i] <- scad(x[i], 1, 3, 1)
}
plot(y~x, type = 'l', lty = 1,
ylab = expression(paste(Omega["SCAD"],"(", xi, ")" )),
xlab = expression(paste(xi)),
lwd = 2,
main = "Weighted SCAD Regularization")
for (i in seq(length(x))) {
y[i] <- scad(x[i], 1, 3, 2)
}
lines(y~x, col = 2, lty = 2, lwd = 2)
for (i in seq(length(x))) {
y[i] <- scad(x[i], 1, 3, 0.5)
}
lines(y~x, col = 3, lty = 3, lwd = 2)
for (i in seq(length(x))) {
y[i] <- scad(x[i], 1, 3, 0)
}
lines(y~x, col = 4, lty = 4, lwd = 2)
legend("bottomright",
title = expression(paste(lambda[1], " = 1, ", lambda[2], " = 3")),
legend = c("w = 0.0", "w = 0.5", "w = 1.0", "w = 2.0"),
lty = c(4, 3, 1, 2), col = c(4, 3, 1, 2), lwd = 2, bg = "white")
dev.off()
scad_thresh <- function(x, l1, l2, w) {
if (abs(x) <= 2*l1*w) {
y <- lasso_thresh(x, l1, w)
} else if (2*l1*w < abs(x) & abs(x) < l1 * l2 * w) {
y <- (l2-1)/(l2-2) * (lasso_thresh(x = x, l = l1 * l2/(l2-1), w = w))
} else {
y <- x
}
return(y)
}
pdf(file = "/Users/YLIAN/Documents/Research/REE/JSS/SCAD_thresh.pdf", width = 6, height = 5)
x <- seq(-6.5, 6.5, by = 0.01)
y <- numeric(length(x))
for (i in seq(length(x))) {
y[i] <- scad_thresh(x[i], 1, 3, 1)
}
plot(y~x, type = 'l', lty = 1,
ylab = expression(paste(S["SCAD"],"(", xi, ")" )),
xlab = expression(paste(xi)),
lwd = 2,
main = "Weighted SCAD Thresholding")
for (i in seq(length(x))) {
y[i] <- scad_thresh(x[i], 1, 3, 2)
}
lines(y~x, col = 2, lty = 2, lwd = 2)
for (i in seq(length(x))) {
y[i] <- scad_thresh(x[i], 1, 3, 0.5)
}
lines(y~x, col = 3, lty = 3, lwd = 2)
for (i in seq(length(x))) {
y[i] <- scad_thresh(x[i], 1, 3, 0)
}
lines(y~x, col = 4, lty = 4, lwd = 2)
legend("bottomright",
title = expression(paste(lambda[1], " = 1, ", lambda[2], " = 3")),
legend = c("w = 0.0", "w = 0.5", "w = 1.0", "w = 2.0"),
lty = c(4, 3, 1, 2), col = c(4, 3, 1, 2), lwd = 2, bg = "white")
dev.off()
# lasso
lasso <- function(x, l, w) {
y <- l * w * abs(x)
return(y)
}
pdf(file = "/Users/YLIAN/Documents/Research/REE/JSS/Lasso_value.pdf", width = 6, height = 5)
x <- seq(-6.5, 6.5, by = 0.01)
y <- numeric(length(x))
for (i in seq(length(x))) {
y[i] <- lasso(x[i], 1, 1)
}
plot(y~x, type = 'l', lty = 1,
ylab = expression(paste(Omega["Lasso"],"(", xi, ")" )),
xlab = expression(paste(xi)),
lwd = 2,
main = "Weighted Lasso Regularization")
for (i in seq(length(x))) {
y[i] <- lasso(x[i], 1, 2)
}
lines(y~x, col = 2, lty = 2, lwd = 2)
for (i in seq(length(x))) {
y[i] <- lasso(x[i], 1, 0.5)
}
lines(y~x, col = 3, lty = 3, lwd = 2)
for (i in seq(length(x))) {
y[i] <- lasso(x[i], 1, 0)
}
lines(y~x, col = 4, lty = 4, lwd = 2)
legend("bottomright",
title = expression(paste(lambda, " = 1")),
legend = c("w = 0.0", "w = 0.5", "w = 1.0", "w = 2.0"),
lty = c(4, 3, 1, 2), col = c(4, 3, 1, 2), lwd = 2, bg = "white")
dev.off()
lasso_thresh <- function(x, l, w) {
if (abs(x) > l * w) {
y <- x - x/abs(x)*l*w
} else {
y <- 0
}
}
pdf(file = "/Users/YLIAN/Documents/Research/REE/JSS/Lasso_thresh.pdf", width = 6, height = 5)
x <- seq(-6.5, 6.5, by = 0.01)
y <- numeric(length(x))
for (i in seq(length(x))) {
y[i] <- lasso_thresh(x[i], 1, 1)
}
plot(y~x, type = 'l', lty = 1,
ylab = expression(paste(S["Lasso"],"(", xi, ")" )),
xlab = expression(paste(xi)),
lwd = 2,
main = "Weighted Lasso Thresholding")
for (i in seq(length(x))) {
y[i] <- lasso_thresh(x[i], 1, 2)
}
lines(y~x, col = 2, lty = 2, lwd = 2)
for (i in seq(length(x))) {
y[i] <- lasso_thresh(x[i], 1, 0.5)
}
lines(y~x, col = 3, lty = 3, lwd = 2)
for (i in seq(length(x))) {
y[i] <- lasso_thresh(x[i], 1, 0)
}
lines(y~x, col = 4, lty = 4, lwd = 2)
legend("bottomright",
title = expression(paste(lambda, " = 1")),
legend = c("w = 0.0", "w = 0.5", "w = 1.0", "w = 2.0"),
lty = c(4, 3, 1, 2), col = c(4, 3, 1, 2), lwd = 2, bg = "white")
dev.off()
devtools::check_mac_release()
devtools::check_mac_release()
devtools::check_mac_release()
build_vignettes()
devtools::build_vignettes()
.Last.error.trace
devtools::build_vignettes()
devtools::build_vignettes()
library(ktweedie)
Sys.which(Sys.getenv())
Sys.which(Sys.getenv("qpdf"))
Sys.which(Sys.getenv("R_qpdf", "qpdf"))
Sys.which(Sys.getenv("R_qpdf"))
Sys.which(Sys.getenv("R_qpdf", "qpdf"))
devtools::check_win_release()
devtools::check_mac_release()
install.libs("qpdf")
install.packages("~/Downloads/qpdf-10.0.4-darwin.20-arm64.tar.xz", repos = NULL)
source("https://mac.R-project.org/bin/install.R")
install.libs("qpdf")
Sys.which(Sys.getenv("R_qpdf", "qpdf"))
Sys.which(Sys.getenv("R_qpdf", "qpdf"))
Sys.which(Sys.getenv("R_qpdf", "qpdf"))
Sys.which(Sys.getenv())
Sys.which(Sys.getenv("R_pqdf", "qpdf"))
Sys.which(Sys.getenv())
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.setenv("R_QPDF", "qpdf")
Sys.setenv("qpdf")
Sys.setenv("qpdf" = "/opt/R/arm64/bin/qpdf")
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.which(Sys.getenv())
attr(Sys.which(Sys.getenv()), "names")
Sys.setenv("Q_QPDF" = "/opt/R/arm64/bin/qpdf")
attr(Sys.which(Sys.getenv()), "names")
Sys.which(Sys.getenv())
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.which(Sys.getenv("R_QPDF"))
Sys.which(Sys.getenv("qpdf"))
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.which(Sys.getenv("qpdf"))
Sys.which(Sys.getenv())
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.which(Sys.getenv("qpdf"))
args = list(/opt/R/arm64/bin/qpdf)
args = list("/opt/R/arm64/bin/qpdf")
names(args) <- "R_QPDF"
do.call(sys.sete\)
do.call(Sys.setenv, args)
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
library(ktweedie)
devtools::check_win_release()
library(ktweedie)
( cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-10, 1e0),
sigma = c(1e-10, 1e0),
ncoefs = 6) )
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
args <- list("/opt/R/arm64/bin/qpdf")
names(args) <- "R_QPDF"
do.call(Sys.setenv, args)
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
libarary(ktweedie)
library(ktweedie)
( cv2d <- ktd_cv2d(x = dat$x, y = dat$y,
kernfunc = rbfdot,
lambda = c(1e-10, 1e0),
sigma = c(1e-10, 1e0),
ncoefs = 6) )
usethis::use_github_action("check-standard")
use_github_action_check_standard()
usethis::use_github_action_check_standard()
